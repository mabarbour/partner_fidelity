{
    "collab_server" : "",
    "contents" : "\nset.seed(34) # make sure simulations give same output\n\n## LOAD REQUIRED LIBRARIES ----\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(cowplot)\n\n## LOAD AND MANAGE THE DATA ----\nnetwork.df <- read_csv(\"t_glmm_plus_connectance.csv\") %>%\n  mutate(network_id = as.factor(network_id),\n         id_pair = as.factor(id_pair),\n         type = as.factor(type),\n         c.norm_deg_sp_1 = normalized_degree_sp_1 - mean(normalized_degree_sp_1),\n         c.norm_deg_sp_2 = normalized_degree_sp_2 - mean(normalized_degree_sp_2),\n         sc.norm_deg_sp_1 = scale(normalized_degree_sp_1),\n         sc.norm_deg_sp_2 = scale(normalized_degree_sp_2),\n         expected_probability = (normalized_degree_sp_1 + normalized_degree_sp_2)/2)\n\n\n## SET NUMBER OF CORES FOR MODEL ----\noptions(mc.cores=parallel::detectCores ()) # Run on multiple cores\n\n## EXPLORE THE DATA ----\ntable(network.df$subtype) # dataset dominated by host-parasite and plant-pollinator interactions\n\ntable(network.df$network_id) # 136 unique networks, substantial heterogeneity in which interactions come from each network\nsummary(c(table(network.df$network_id)))\n\ntable(network.df$id_pair) # 4075 unique interactions\nsummary(c(table(network.df$id_pair))) # most interactions co-occur 2-3 times, but the max is 19.\n\n# both species 1 and 2 have similar range of normalized degree\nsummary(network.df$normalized_degree_sp_1)\nsummary(network.df$normalized_degree_sp_2)\n\nmean.norm_deg_sp_1 <- mean(network.df$normalized_degree_sp_1)\nmean.norm_deg_sp_2 <- mean(network.df$normalized_degree_sp_2)\n\n## Explore the relationship between normalized degree and interaction type\n\nbinomial_smooth <- function(...) {\n  geom_smooth(method = \"glm\", method.args = list(family = \"binomial\"), ...)\n}\n\nggplot(network.df, aes(x = normalized_degree_sp_1, y = connected, color = type)) +\n  geom_point() + \n  binomial_smooth() \nggplot(network.df, aes(x = normalized_degree_sp_2, y = connected, color = type)) +\n  geom_point() + \n  binomial_smooth() \nggplot(network.df %>% mutate(connected = as.factor(connected)), \n       aes(x = normalized_degree_sp_2, y = normalized_degree_sp_1, fill = connected, color = connected)) +\n  geom_point(shape = 21, size = 2) + \n  facet_wrap(~type) + \n  scale_fill_manual(values = c(\"white\", \"black\")) + \n  scale_color_manual(values = c(\"grey\", \"black\")) \n\n# focus on mutualists\nggplot(network.df %>% mutate(connected = as.factor(connected), \n                             sp_1_type = factor(ifelse(normalized_degree_sp_1 > mean.norm_deg_sp_1, \"sp_1_generalist\", \"sp_1_specialist\"), levels = c(\"sp_1_generalist\", \"sp_1_specialist\")),\n                             sp_2_type = factor(ifelse(normalized_degree_sp_2 > mean.norm_deg_sp_2, \"sp_2_generalist\", \"sp_2_specialist\"), levels = c(\"sp_2_specialist\", \"sp_2_generalist\"))) %>%\n         filter(type == \"M\"), \n       aes(x = normalized_degree_sp_1, y = normalized_degree_sp_2, fill = connected, color = connected)) +\n  geom_point(shape = 21, size = 4) + \n  facet_grid(sp_1_type ~ sp_2_type, scales = \"free\") + # facet_wrap()\n  scale_fill_manual(values = c(\"white\", \"black\")) + \n  scale_color_manual(values = c(\"grey\", \"black\")) + \n  theme_bw()\n\n\n# focus on antagonists\nggplot(network.df %>% mutate(connected = as.factor(connected), \n                             sp_1_type = factor(ifelse(normalized_degree_sp_1 > mean.norm_deg_sp_1, \"sp_1_generalist\", \"sp_1_specialist\"), levels = c(\"sp_1_generalist\", \"sp_1_specialist\")),\n                             sp_2_type = factor(ifelse(normalized_degree_sp_2 > mean.norm_deg_sp_2, \"sp_2_generalist\", \"sp_2_specialist\"), levels = c(\"sp_2_specialist\", \"sp_2_generalist\"))) %>%\n         filter(type == \"A\"), \n       aes(x = normalized_degree_sp_1, y = normalized_degree_sp_2, fill = connected, color = connected)) +\n  geom_point(shape = 21, size = 4) + \n  facet_grid(sp_1_type ~ sp_2_type, scales = \"free\") + # facet_wrap()\n  scale_fill_manual(values = c(\"white\", \"black\")) + \n  scale_color_manual(values = c(\"grey\", \"black\")) + \n  theme_bw()\n\n# from species 1 perspective\nggplot(network.df %>% mutate(connected = connected, \n                             sp_1_type = factor(ifelse(normalized_degree_sp_1 > mean.norm_deg_sp_1, \"sp_1_generalist\", \"sp_1_specialist\"), levels = c(\"sp_1_generalist\", \"sp_1_specialist\")),\n                             sp_2_type = factor(ifelse(normalized_degree_sp_2 > mean.norm_deg_sp_2, \"sp_2_generalist\", \"sp_2_specialist\"), levels = c(\"sp_2_specialist\", \"sp_2_generalist\"))),\n       aes(x = normalized_degree_sp_1, y = connected, fill = sp_2_type, color = sp_2_type)) +\n  geom_point(shape = 21, size = 4) + \n  binomial_smooth() +\n  facet_wrap(~type, scales = \"free\") \n\n# from species 2 perspective\nggplot(network.df %>% mutate(connected = connected, \n                             sp_1_type = factor(ifelse(normalized_degree_sp_1 > mean.norm_deg_sp_1, \"sp_1_generalist\", \"sp_1_specialist\"), levels = c(\"sp_1_generalist\", \"sp_1_specialist\")),\n                             sp_2_type = factor(ifelse(normalized_degree_sp_2 > mean.norm_deg_sp_2, \"sp_2_generalist\", \"sp_2_specialist\"), levels = c(\"sp_2_specialist\", \"sp_2_generalist\"))),\n       aes(x = normalized_degree_sp_2, y = connected, fill = sp_1_type, color = sp_1_type)) +\n  geom_point(shape = 21, size = 4) + \n  binomial_smooth() +\n  facet_wrap(~type, scales = \"free\")\n\n## BAYESIAN MODEL OF INTERACTION PROBABILITY ----\ninteraction.formula <- brmsformula(connected ~                                # probability of species interaction\n                                     type*sc.norm_deg_sp_1*sc.norm_deg_sp_2 +   # 3-way interaction between type and normalized degree of each species\n                                     (1 | network_id) +                       # allow probability of interaction to vary among networks\n                                     (1 | subtype) +                          # allow probability of interaction to vary among interaction subtypes.\n                                     (1 | species_1) +                        # allow probability of interaction to vary among resource species\n                                     (1 | species_2) +                        # allow probability of interaction to vary among consumer species\n                                     (1 | id_pair))                           # allow probability of interaction to vary among unique species interactions\n  \n\n## RATIONALE FOR MODEL PRIORS ----\n\nget_prior(interaction.formula, data = network.df, family = bernoulli()) # see which priors I need to set.\n\n## INTERACTION TYPE\n\n# playing around with different hypothetical probabilities suggests to me that the logistic regression coefficient will be \n# between -5 and 5. Therefore, a normal prior with mean 0 and sd = 2, seems reasonable to me.\n\n# Let's take a hypothetical example, where the effect of interaction type is really large, ranging from\n# a probability of 0.25 to 0.75. This corresponds to a logistic regression coefficient of ~2.2\npM <- 0.75 # probability of a mutualistic interaction when two species co-occur \npA <- 0.25 # probability of an antagonistic interaction when two species co-occur \nmu_mutualist <- log(pM / (1-pM)) - log(pA / (1-pA)) # logistic regression coefficient, which is the difference in log-odds for 1 unit increase in the predictor\n\n# I would expect such a large effect to be unlikely though. Also, whether mutualism or antagonism has a \n# positive or negative effect is unclear to me. I could imagine it either way. So let's specify a \n# regularizing prior where the prior for the coefficient is centered on zero, but the variance is large\n# enough to allow for bigger effects if there is enough evidence to support them.\nsamp <- 1000\nsd_type <- data.frame(density = c(rnorm(samp, 0, 0.5),\n                                  rnorm(samp, 0, 1),\n                                  rnorm(samp, 0, 2),\n                                  rnorm(samp, 0, 4)),\n                      standard_deviation = c(rep(\"sd_0.5\", samp),\n                                             rep(\"sd_1\", samp),\n                                             rep(\"sd_2\", samp),\n                                             rep(\"sd_4\", samp)))\nggplot(sd_type, aes(x = density, fill = standard_deviation)) + \n  geom_density(alpha = 0.5) + \n  geom_vline(xintercept = mu_mutualist, linetype = \"dotted\") # big effect\n\n# I think a normal prior with mean = 0 and sd = 2 would be appropriate.\n\n## NORMALIZED DEGREES\n\n# I expect for the normalized degree of a species to always have a positive relationship with the \n# probability of an interaction. Biologically, it does not make sense that this relationship could \n# ever be negative, which is why I will impose a lower bound of zero on this parameter. By default,\n# I would expect this relationship to be 1:1 between the probability of observing an interaction and \n# the normalized degree of a species. Since the normalized degree of a species defines its probability\n# of interacting with a co-occuring partner, regardless of its identity, my prior expectation is that \n# there is a 1:1 relationship between the normalized degree of a species and its probability of interacting\n# with another species. In other words, the probability of observing an interaction is the same as\n# the normalized degree. Let's get some intuition as to what this prior looks like when normalized degree\n# is on a standardized scale (1 SD above the mean). I chose to only look above because the normalized degree of species\n# ranges up to 3 SD above the mean, so looking from the mean to +1 SD covers much of the data range.\npMean_sp1 <- mean(network.df$normalized_degree_sp_1) # probability of average species interacting\npGen_sp1 <- mean(network.df$normalized_degree_sp_1) + sd(network.df$normalized_degree_sp_1) # probability of a relatively generalized species interacting\n\nmu_sc.norm_deg_sp1 <- log(pGen_sp1 / (1-pGen_sp1)) - log(pMean_sp1 / (1-pMean_sp1)) # logistic regression coefficient, which is the difference in log-odds for 1 standardized unit increase in a species normalized degree.\n\npMean_sp2 <- mean(network.df$normalized_degree_sp_2) # probability of average species interacting\npGen_sp2 <- mean(network.df$normalized_degree_sp_2) + sd(network.df$normalized_degree_sp_2) # probability of a relatively generalized species interacting\n\nmu_sc.norm_deg_sp2 <- log(pGen_sp2 / (1-pGen_sp2)) - log(pMean_sp2 / (1-pMean_sp2)) # logistic regression coefficient, which is the difference in log-odds for 1 standardized unit increase in a species normalized degree.\n\n# Now, this is only a prior expectation, and to reflect some uncertainty around this prior, I'm going\n# to specify a normal distribution centered on this mean and explore different variances\nsamp <- 1000\nsd_sp1 <- data.frame(density = c(rnorm(samp, mu_sc.norm_deg_sp1, 0.5),\n                                 rnorm(samp, mu_sc.norm_deg_sp1, 1),\n                                 rnorm(samp, mu_sc.norm_deg_sp1, 2),\n                                 rnorm(samp, mu_sc.norm_deg_sp1, 4)),\n                     standard_deviation = c(rep(\"sd_0.5\", samp),\n                                            rep(\"sd_1\", samp),\n                                            rep(\"sd_2\", samp),\n                                            rep(\"sd_4\", samp)))\nggplot(sd_sp1, aes(x = density, fill = standard_deviation)) + geom_density(alpha = 0.5)\n\n# Most standardized logistic regression coefficients are less than 5, so I feel that specifying a standard\n# deviation of 2 is reasonable since it more than covers the range from 0 to 5 (and I never expect this coefficient to be negative). It will\n# also make the data \"work\" for larger values.\n\n# For interactions involving interaction type, I'm going to specify the same regularizing prior\n# as for \"type\", because I could see interaction type having positive or negative effects on this relationship\n# and I want to make the data \"work\" for those strong effects.\n# For the interaction with normalized degree, I expect this relationship to always be positive, but I don't know how much\n# so I'm going to set a lower bound of zero, but I'll increase the standard deviation to 2 to allow more flexibility\n# in having positive values.\n\n\n## SET PRIORS ----\ninteraction.priors <- c(set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM\"),\n                        set_prior(\"normal(1,2)\", class = \"b\", coef = \"sc.norm_deg_sp_1\"),\n                        set_prior(\"normal(1,2)\", class = \"b\", coef = \"sc.norm_deg_sp_2\"),\n                        set_prior(\"normal(0,2)\", class = \"b\", coef = \"sc.norm_deg_sp_1:sc.norm_deg_sp_2\"),\n                        set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_1\"),\n                        set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_2\"),\n                        set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_1:sc.norm_deg_sp_2\"),\n                        set_prior(\"normal(0,2)\", class = \"sd\"))\n\n## MODEL OF COMMUNITY-CONTEXT DEPENDENCE\ncommunity_context <- brm(connected ~ type + \n                           (1 | network_id) + \n                           (1 | subtype) + \n                         #  (1 | species_1) + \n                        #   (1 | species_2) + \n                           (1 | id_pair) +\n                           (1 | id_pair:network_id), # model whether community context id_pair:network_id depends on type of interaction\n                         data = network.df, \n                         family = bernoulli(),\n                         prior = c(set_prior(\"normal(0,1)\", class = \"b\", coef = \"typeM\"),\n                                   set_prior(\"normal(0,1)\", class = \"sd\")),\n                         algorithm = \"fullrank\",\n                         chains = 4,\n                         #iter = 4000,\n                         control = list(adapt_delta = 0.99, max_treedepth = 20),\n                         save_model = \"model_output/community_context\") \n\nsummary(community_context)\n\n## MODEL WITH ONLY INTERACTION TYPE ----\ninteraction.type.only <- brm(connected ~ type + (1 | network_id) + (1 | subtype) + (1 | species_1) + (1 | species_2) + (1 | id_pair),\n                             data = network.df, \n                             family = bernoulli(),\n                             prior = c(set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM\"),\n                                       set_prior(\"normal(0,2)\", class = \"sd\")),\n                             algorithm = \"sampling\",\n                             chains = 4,\n                             control = list(adapt_delta = 0.99, max_treedepth = 20),\n                             save_model = \"model_output/interaction_type_only\")\n\nsummary(interaction.type.only)\n\ntype_main_only <- plot(marginal_effects(interaction.type.only, effects = \"type\"))[[1]] +\n  ggplot2::xlab(\"Interaction Type\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type_main_only.pdf\")\n\n## RUN MODEL (~45 MIN.) ----\ninteraction.test <- brm(interaction.formula,\n                        data = network.df, \n                        family = bernoulli(),\n                        prior = interaction.priors,\n                        algorithm = \"sampling\",\n                        chains = 4,\n                        control = list(adapt_delta = 0.99, max_treedepth = 20))#,\n                        #save_model = \"model_output/interaction_test\")\n\n\n# plot(interaction.test) # everything looks good\nsummary(interaction.test)\n\n# Calculates the predicted variance divided by predicted variance plus error variance. \n# This Bayesian R2 can be interpreted as a data-based estimate of the proportion of variance explained for new data.\nbayes_R2(interaction.test) # 40.1% of the variance, 95% CI = 38.8% - 41.4%\n\n# see how dropping the 3-way interaction affects the model fit\ndrop.interaction.priors <- c(set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM\"),\n                             set_prior(\"normal(1,2)\", class = \"b\", coef = \"sc.norm_deg_sp_1\"),\n                             set_prior(\"normal(1,2)\", class = \"b\", coef = \"sc.norm_deg_sp_2\"),\n                             set_prior(\"normal(0,2)\", class = \"b\", coef = \"sc.norm_deg_sp_1:sc.norm_deg_sp_2\"),\n                             set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_1\"),\n                             set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_2\"),\n                             #set_prior(\"normal(0,2)\", class = \"b\", coef = \"typeM:sc.norm_deg_sp_1:sc.norm_deg_sp_2\"),\n                             set_prior(\"normal(0,2)\", class = \"sd\"))\n\ndrop.interaction <- brm(connected ~ (type+sc.norm_deg_sp_1+sc.norm_deg_sp_2)^2 + \n                          (1 | network_id) + (1 | subtype) + (1 | species_1) + (1 | species_2) + (1 | id_pair),\n                        data = network.df, family = bernoulli(), prior = drop.interaction.priors,\n                        algorithm = \"sampling\", chains = 4, control = list(adapt_delta = 0.99, max_treedepth = 20))\nbayes_R2(drop.interaction) \nLOO(drop.interaction, interaction.test, reloo = TRUE) \n\n#LOOIC     SE\n#drop.interaction                    11647.36 118.61\n#interaction.test                    11622.12 116.99\n#drop.interaction - interaction.test    25.24  22.31\n\n## SAVE MODEL SUMMARY INFORMATION ----\n\n# fixed effects\ninteraction_fixef <- round(as.data.frame(summary(interaction.test)[[18]]),2)\ninteraction_fixef$coefficients <- rownames(interaction_fixef)\nwrite_csv(select(interaction_fixef, coefficients, Estimate:Rhat), \"model_output/interaction_summary_fixef.csv\")\n\n# random effect summary\nplyr::ldply(summary(interaction.test)[[20]]) %>%\n  write_csv(., \"model_output/interaction_summary_ranef.csv\")\n\n# individual random effects\ninteraction_ranef_sp1 <- round(as.data.frame(ranef(interaction.test)$species_1),2)\ninteraction_ranef_sp1$species_1 <- rownames(interaction_ranef_sp1)\nwrite_csv(interaction_ranef_sp1, \"model_output/interaction_ranef_sp1.csv\")\n\ninteraction_ranef_sp2 <- round(as.data.frame(ranef(interaction.test)$species_2),2)\ninteraction_ranef_sp2$species_2 <- rownames(interaction_ranef_sp2)\nwrite_csv(interaction_ranef_sp2, \"model_output/interaction_ranef_sp2.csv\")\n\ninteraction_ranef_network_id <- round(as.data.frame(ranef(interaction.test)$network_id),2)\ninteraction_ranef_network_id$network_id <- rownames(interaction_ranef_network_id)\nwrite_csv(interaction_ranef_network_id, \"model_output/interaction_ranef_network_id.csv\")\n\ninteraction_ranef_subtype <- round(as.data.frame(ranef(interaction.test)$subtype),2)\ninteraction_ranef_subtype$subtype <- rownames(interaction_ranef_subtype)\nwrite_csv(interaction_ranef_subtype, \"model_output/interaction_ranef_subtype.csv\")\n\ninteraction_ranef_id_pair <- round(as.data.frame(ranef(interaction.test)$id_pair),2)\ninteraction_ranef_id_pair$id_pair <- rownames(interaction_ranef_id_pair)\nwrite_csv(interaction_ranef_id_pair, \"model_output/interaction_ranef_id_pair.csv\")\n\n## PLOT AND SAVE MODEL RESULTS ----\n\nviridis6 <- function() {\n  # colours taken from the viridis package\n  c(\"#440154\", \"#414487\", \"#2A788E\", \"#22A884\", \"#7AD151\", \"#FDE725\")\n} # taken from https://github.com/paul-buerkner/brms/blob/master/R/plots.R\n\ntype_main <- plot(marginal_effects(interaction.test, effects = \"type\"))[[1]] +\n  ggplot2::xlab(\"Interaction Type\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type_main.pdf\")\n\nnorm_sp1 <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_1\"))[[1]] +\n  ggplot2::xlab(\"Resource Normalized Degree\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/norm_sp1.pdf\")\n\nnorm_sp2 <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_2\"))[[1]] +\n  ggplot2::xlab(\"Consumer Normalized Degree\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/norm_sp2.pdf\")\n\ntype.norm_sp1 <- plot(marginal_effects(interaction.test, effects = \"type:sc.norm_deg_sp_1\"))[[1]] +\n  ggplot2::xlab(\"Interaction Type\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type.norm_sp1.pdf\")\n\ntype.norm_sp1_cont <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_1:type\"))[[1]] +\n  ggplot2::xlab(\"Normalized Degree Sp. 1 (scaled)\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type.norm_sp1_cont.pdf\")\n\ntype.norm_sp2 <- plot(marginal_effects(interaction.test, effects = \"type:sc.norm_deg_sp_2\"))[[1]] +\n  ggplot2::xlab(\"Interaction Type\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type.norm_sp2.pdf\")\n\ntype.norm_sp2_cont <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_2:type\"))[[1]] +\n  ggplot2::xlab(\"Normalized Degree Sp. 2 (scaled)\") +\n  ggplot2::ylab(\"Probability of Interaction\")\nggsave(\"plots/type.norm_sp2_cont.pdf\")\n\nnorm_sp1.norm_sp2 <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_1:sc.norm_deg_sp_2\", surface = TRUE), stype = \"raster\")[[1]] +\n  ggplot2::xlab(\"Resource Normalized Degree (scaled)\") +\n  ggplot2::ylab(\"Consumer Normalized Degree (scaled)\") +\n  ggplot2::scale_fill_gradientn(colors = viridis6(), name = \"Probability of\\n Interaction\")\nggsave(\"plots/norm_sp1.norm_sp2.pdf\")\n\n## NEW PLOTS FOR FIGURE 2 ##\n# note that the credible intervals are much smaller\n\n# suggests to me that specialized consumers have a much higher probability of interacting with generalist resources \n# in mutualistic vs. antagonistic interactions\nasymmetry_MvA <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_2:sc.norm_deg_sp_1\", \n                      conditions = data.frame(type = c(\"M\",\"A\"), \n                                              row.names = c(\"Mutualistic\",\"Antagonistic\")),\n                      int_conditions = list(sc.norm_deg_sp_1 = c(-1,1)),\n                      probs = c(0.25,0.75)))[[1]]\nggsave(\"new_plots_fig_2/asymmetry_MvA.pdf\")\n\n# not that informative, although it contains similar info\nalt_asymmetry_MvA <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_1:sc.norm_deg_sp_2\", \n                      conditions = data.frame(type = c(\"M\",\"A\"), \n                                              row.names = c(\"Mutualistic\",\"Antagonistic\")),\n                      int_conditions = list(sc.norm_deg_sp_2 = c(-1,1)),\n                      probs = c(0.25,0.75)))[[1]]\nggsave(\"new_plots_fig_2/alt_asymmetry_MvA.pdf\")\n\n# I like this perspective the most.\n# as above, suggests to me that specialized consumers have a much higher probability of interacting with generalist resources \n# in mutualistic vs. antagonistic interactions\nasymmetry_SvG <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_1:type\",\n                      conditions = data.frame(sc.norm_deg_sp_2 = c(-1,1),\n                                              row.names = c(\"Specialist consumer (ND=-1)\", \"Generalist consumer (ND=1)\")),\n                      probs = c(0.25,0.75)))[[1]] +\n  ggplot2::ylab(\"Partner fidelity\") +\n  ggplot2::xlab(\"Resource Normalized Degree (scaled)\")\nggsave(\"new_plots_fig_2/asymmetry_SvG.pdf\")\n\n# Presents similar information, but I think it is less informative\nalt_asymmetry_SvG <- plot(marginal_effects(interaction.test, effects = \"sc.norm_deg_sp_2:type\",\n                      conditions = data.frame(sc.norm_deg_sp_1 = c(-1,1),\n                                              row.names = c(\"Specialist resource (ND=-1)\", \"Generalist resource (ND=1)\")),\n                      probs = c(0.25,0.75)))[[1]] +\n  ggplot2::ylab(\"Partner fidelity\") +\n  ggplot2::xlab(\"Consumer Normalized Degree (scaled)\")\ncowplot::ggsave(\"new_plots_fig_2/alt_asymmetry_SvG.pdf\")\n\nheatmap.data <- marginal_effects(interaction.test, \n                                 effects = c(\"sc.norm_deg_sp_1:sc.norm_deg_sp_2\"),\n                                 conditions = data.frame(type = c(\"M\",\"A\"), \n                                                         row.names = c(\"Mutualistic\",\"Antagonistic\")), \n                                 surface = TRUE)\nwrite_csv(heatmap.data[[1]], \"model_output/heatmap_data.csv\") # export so I can tailor these plots later since we are more interested in these interactions\n\nsource(\"plot_heatmaps.R\") # source code and plot 3-way interactions.\n\n## EXAMINE ROBUSTNESS OF MODEL WITH DEFAULT PRIORS ----\n\nget_prior(interaction.formula, data = network.df) # default priors\n\n# take a really long time to run\ninteraction.test.nopriors <- brm(interaction.formula,\n                        data = network.df, \n                        family = bernoulli(),\n                        #prior = interaction.priors,\n                        algorithm = \"sampling\",\n                        chains = 4,\n                        \n                        # adjusted control parameters in order for model to converge.\n                        control = list(adapt_delta = 0.999,\n                                       max_treedepth = 20),\n                        save_model = \"model_output/no_priors/interaction_test_nopriors\")\n\n## Examine and save all summary output\n\n# plot(interaction.test.nopriors) # everything looks good\nsummary(interaction.test.nopriors)\n\n# fixed effects\nnoprior_fixef <- round(as.data.frame(summary(interaction.test.nopriors)[[17]]),2)\nnoprior_fixef$coefficients <- rownames(noprior_fixef)\nwrite_csv(select(noprior_fixef, coefficients, Estimate:Rhat), \"model_output/no_priors/nopriors_summary_fixef.csv\")\n\n# random effect summary\nplyr::ldply(summary(interaction.test.nopriors)[[20]]) %>%\n  write_csv(., \"model_output/no_priors/nopriors_summary_randeff.csv\")\n\n# individual random effects\nnoprior_ranef_sp1 <- round(as.data.frame(ranef(interaction.test.nopriors)$species_1),2)\nnoprior_ranef_sp1$species_1 <- rownames(noprior_ranef_sp1)\nwrite_csv(noprior_ranef_sp1, \"model_output/no_priors/nopriors_ranef_sp1.csv\")\n\nnoprior_ranef_sp2 <- round(as.data.frame(ranef(interaction.test.nopriors)$species_2),2)\nnoprior_ranef_sp2$species_2 <- rownames(noprior_ranef_sp2)\nwrite_csv(noprior_ranef_sp2, \"model_output/no_priors/nopriors_ranef_sp2.csv\")\n\nnoprior_ranef_network_id <- round(as.data.frame(ranef(interaction.test.nopriors)$network_id),2)\nnoprior_ranef_network_id$network_id <- rownames(noprior_ranef_network_id)\nwrite_csv(noprior_ranef_network_id, \"model_output/no_priors/nopriors_ranef_network_id.csv\")\n\nnoprior_ranef_subtype <- round(as.data.frame(ranef(interaction.test.nopriors)$subtype),2)\nnoprior_ranef_subtype$subtype <- rownames(noprior_ranef_subtype)\nwrite_csv(noprior_ranef_subtype, \"model_output/no_priors/nopriors_ranef_subtype.csv\")\n\nnoprior_ranef_id_pair <- round(as.data.frame(ranef(interaction.test.nopriors)$id_pair),2)\nnoprior_ranef_id_pair$id_pair <- rownames(noprior_ranef_id_pair)\nwrite_csv(noprior_ranef_id_pair, \"model_output/no_priors/nopriors_ranef_id_pair.csv\")\n",
    "created" : 1540473140622.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3345833998",
    "id" : "251C34FA",
    "lastKnownWriteTime" : 1557905498,
    "last_content_update" : 1557905498,
    "path" : "~/Dropbox/Arxhina_stats/arxhina_final.R",
    "project_path" : "arxhina_final.R",
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}